<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>Configuration</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style>
body { font:80% Verdana,Tahoma,Arial,sans-serif; }
h1, h2, h3, h4 {  font-family: "Trebuchet MS",Georgia,"Times New Roman",serif; }
ul.toc { padding: 4px; margin-left: 0; }
ul.toc li { list-style-type:none; }
ul.toc li.heading2 { margin-left: 1em; }
ul.toc li.heading3 { margin-left: 2em; }
a.wiki-anchor { display: none; margin-left: 6px; text-decoration: none; }
a.wiki-anchor:hover { color: #aaa !important; text-decoration: none; }
h1:hover a.wiki-anchor, h2:hover a.wiki-anchor, h3:hover a.wiki-anchor { display: inline; color: #ddd; }
</style>
</head>
<body>
<ul class="toc"><li><a href="#Configuration-Info-representation-and-semantics">Configuration Info representation and semantics</a><ul><li><a href="#Background">Background</a></li><li><a href="#Strategy">Strategy</a></li><li><a href="#Semantics-of-config-elements">Semantics of config elements</a><ul><li><a href="#Model-and-details">Model and details</a></li><li><a href="#Examples">Examples</a></li></ul>
</li><li><a href="#Architecture-overview">Architecture overview</a></li></ul></li></ul>


	<h1  id="Configuration-Info-representation-and-semantics">Configuration Info representation and semantics<a href="#Configuration-Info-representation-and-semantics" class="wiki-anchor">&para;</a></h1>


	<p>9/22/10 -- jrd</p>


	<p>rev 1</p>


	<p>Here we present a proposed scheme for handling the representation of configuration info for images being deployed in a cloud environment.</p>


	<h2  id="Background">Background<a href="#Background" class="wiki-anchor">&para;</a></h2>


	<p>Most of the time, when an app designer/builder is doing anything non-trivial she finds herself in the position of needing to configure the interactions of a particular system with external resources. These external things might be facilities such as storage, network systems with particular properties, "public" services which are accessible in well-known ways, or other machines in close (or even distant) proximity to the system being configured.</p>


	<p>The traditional way to accomplish this goal in the bare-metal world often comes down to wiring down a bunch of config, generally in conf files of various sorts.  At deployment/installation time, there's a bunch of work around setting up the config on each individual machine, in order to get it to talk to all its neighbors, resources, etc. There are tools which make some headway at doing semi-automatic regeneration of config files, but most of them are focussed on doing repetitive tasks, or replaying the same meta-config into a bunch of similar machines, etc.</p>


	<p>A fundamental point which makes this all work is that the machine remembers its state even when you're not using it, and its state is still relevant when you start using it again.  IOW, you don't have to do anything special to configure it other than write some values into some files.  Those files stay around.  You can power the machine off and start it up a month later, and the config is still there, and probably still works.</p>


	<p>That kind of model goes out the window in the cloud.  For the most part, machine instances are ephemeral.  They might come and go on a timescale of minutes, as opposed to years.  Furthermore, they generally are not persistent, ie if you were to fiddle the config in some file in an instance, that state typically doesn't get saved when you shut it down, so you'd have to do it all over again next launch. Finally, in the cloud, you probably don't <strong>want</strong> the detailed config to be persistent, as you might launch today on one set of VMs, and tomorrow on a different set in a different datacenter.  Or even in a different provider.</p>


	<p>What's needed is a way of talking fairly abstractly about machine configuration, and the relationships between machines in a group, and between machines and the surrounding environment.  And then a body of software to take that description, plug in values from the particular deployment, resolve dependencies, and generate the individual configs used for each instance.</p>


	<h2  id="Strategy">Strategy<a href="#Strategy" class="wiki-anchor">&para;</a></h2>


	<p>We introduce the notion of a service.  A service is a description of a particular kind of functionality, with parameters.  Services can be provided or required, ie any given instance can implement a service for use by other instances, or require that a service exist in the environment, so that the instance can use it.</p>


	<p>Examples of services might be</p>


	<ul>
	<li>A network VPN</li>
		<li>An NFS mount</li>
		<li>A database interface</li>
		<li>A storage system of some kind</li>
	</ul>


	<p>Each service description carries with it basic information like name and type, as well as some number of parameters.  Each parameter can be provided or required.  For instance, one could define a service where the service itself is required (an NFS mount called Foo) and carries parameters with it which are also required (Host, Export-name, Mount-point).  One could also have a service which is provided, and provides a parameter (NFS server, provides Host and Export-name).  One could also have a service which is provided, but which <strong>requires</strong> a parameter (NFS server, requires local-storage-name, provides Host and Export-name).</p>


	<p>Part of the strategy for defining machine images involves the idea of collecting a group of content into what amounts to a disk image.  The description for this entity is referred to as a template.  For configuration, it's natural to expect that each software package which goes into a template may have service descriptions, either provided or required, which go with it.  In addition, it <strong>could</strong> make sense for the image as a whole to provide or require services, not tied to a particular software package.</p>


	<p>[Implementation note:  In the fullness of time, we expect that packages (rpms or whatever) will start to carry along the service descriptions with them, so that installing the package automatically populates the relevant piece of service data.  For now, that's hypothetical, therefore it follows that the tooling which creates images will need to have a way of getting that stuff out of band. That process will be partially manual]</p>


	<p>There's a software component in the system called the image factory, which takes in templates, and produces images, plus descriptors for what's in the images.  For the purposes of this discussion, the interesting part of the description is the service/config data which applies to the image.  This description info is called Capability Description Language (CDL).</p>


	<p>We also introduce the notion of an assembly.  An assembly is a description containing a set of images, plus it's own (assembly-level) service config information.  Essentially, the assembly exists to describe groupings of base pieces, each grouping to make up the contents of a VM image.  In addition, the assembly gives a way of describing services at the machine level, as opposed to at the component level.  One use for this capability is to allow for creating a generic image, and launching it different ways, giving it different personalities.</p>


	<p>Finally, we introduce the notion of a deployable.  A deployable is a description of a group of assemblies.  Typically, a deployable would be used to launch a group of (probably heterogeneous) images, which together make up an application.  An example of such a thing might be an e-commerce server, consisting of several load balancers, several lamp-stack instances, and one or more mysql servers.  The deployable, like the assembly and the CDL, can contain config info apropos the entire group.</p>


	<p>The idea of all this is that at launch time, the infrastructure should have enough information to compute the local config for each instance, based on the properties of the backend, the population of instances making up a launch group, and stuff supplied by the user.</p>


	<p>A simplified description of the algorithm used is as follows:</p>


	<p>Launch code decides on essential characteristics of the launch of a group.  This includes which backend, how many instances, what images and other components are used for each instance, etc.</p>


	<p>Config code pulls the CDL for each image, assembly, deployable. Constructs a graph of which required values can be satisfied by which provided values.</p>


	<p>If there are values which the config engine determines cannot be resolved from another instance or the environment, it either throws an error, or prompts the user to supply those values [tbd]</p>


	<p>Once the config engine can tell that the dependency graph is complete, ie there's a way to resolve every required value, it allows the group launch to proceed.</p>


	<p>Each instance for which there is complete configuration info is cleared for launch.</p>


	<p>Each instance which depends on a determined-by-launch value of another instance (for instance an IP address) is held back.</p>


	<p>As instance launches proceed, config engine interacts with core cloud engine to resolve pending required values.  As each dependent instance acquires its required values, it's cleared for launch.</p>


	<p>That's about it.</p>


	<h2  id="Semantics-of-config-elements">Semantics of config elements<a href="#Semantics-of-config-elements" class="wiki-anchor">&para;</a></h2>


	<p>This is where things get really interesting.  Much of what was described above primarily talks about fairly simple cases.  For instance value X, hard-wired in instance 1, and provided, is required to resolve value Y in instance 2.  Or value X, determined at launch time of instance 1, and provided, is required to resolve value Y in instance 2.  But there are more complicated cases which we'll need to handle as well.</p>


	<p>Consider the case where you've got a load-balancer which wants to be told at boot time the list of IP addresses of its clients.  That's not a simple scalar value.  The semantics you want is "collect all the &lt;value ip-address&gt; from all of this class of machine in the cluster, and present that to this other machine as a vector value".</p>


	<p>Consider the case where you've got N of one kind of machine, and M of another, where M serves N.  You want to assign the N->M connections round-robin.  That involves logic at config time which is simpler than "just fetch the value".  You need semantics to describe the round-robin assignment.</p>


	<p>There are some cases which will necessarily be handled outside the core algorithm described above.</p>


	<p>Consider the case where you've got a private network, perhaps on a VPN or something.  Getting a host onto that network involves doing some negotiating at runtime, then getting an address.  But that address isn't known until after you boot.  If your goal is to tell all these machines about each other, so that they can talk over the vpn, you need to boot them all, collect all the data, then distribute the aggregate to the group.  We do not try to solve this class of problem here, rather we suppose that it will be solved by integrating something like matahari into the booting images.</p>


	<h3  id="Model-and-details">Model and details<a href="#Model-and-details" class="wiki-anchor">&para;</a></h3>


	<p>We express the structure of the dependency and config language as xml here.  Please note that this is pseudo-xml, it's not intended to be grammatically correct or optimal xml, rather the intent is simply to describe the structure.  We expect the implementation to use datastructures which look like this, but which may or may not be represented as xml.  It's a design goal of this software that nobody ever sees these raw structures, and the tools for generating them and manipulating them use GUIs and things to present them.  IOW, the fact that they're described as xml should in no way imply that there's ever a foo.xml file which looks like these things.</p>


	<p>In each CDL-like construction (ie, the actual CDL for an image, the assembly which uses it, or the deployable which uses that) there are two vectors of "service" entries, one for provided services, one for required.</p>


	<p>Each service entry is named, and has a type.  Specs for required services may reference either a name or type or both, this aids selecting which parameters get resolved how.</p>


	<p>Each service entry has some number of "param" entries.  Params may be provided or required.</p>


	<p>Params have at minimum a name and value.  The "name" spec is used for matching.  The "value" spec describes one of a number of ways to acquire the actual value at launch time.  Modes of acquiring values include at least:</p>


	<ul>
	<li>fixed (this is a wired value, supplied at one level or another of CDL)</li>
		<li>compute-from-instance  (this value comes from some property of the<br />        booting instance, provided by the CE infrastructure)</li>
		<li>prompt-user  (this value must be provided by the user at launch<br />        time, implying that there's some UI around to handle that)</li>
	</ul>


	<p>There will surely be more.</p>


	<p>value entries which do not come with preconfigured values, and which don't say they get acquired some other way, are expected to be able to be resolved by the engine, by picking through its graph of config info and resolving by name and/or type.  Failure to resolve any param in this way constitutes an error, and the instance cannot be launched.</p>


	<h3  id="Examples">Examples<a href="#Examples" class="wiki-anchor">&para;</a></h3>


	<p>[We should probably rewrite this a bit, rather than just importing the last draft wholesale]</p>


<hr />


	<p>Concrete examples of config flows, using our proposed config model.</p>


	<p>Version 1<br />9/2/10  -- jrd</p>


	<p>This doc builds on the previous efforts to talk about a configuration mechanism for cloud instances.</p>


	<p>Caveats:</p>


	<p>We have a bunch of xml snippets in here.  These do not claim to be finished-product xml, or good xml style, or anything like that.  The important thing is the object model and the semantics.  We'll build "good" xml for it later.</p>


	<p>We are not trying to solve every single configuration problem there is.  The fairly specific goal of this exercise is to define a structure for representing config information which we believe will (a) allow for a good set of common config tasks, and (b) leave room for extensibility and enhancement, for when we flesh out the cloud engine's functionality.  IOW, we want to design something which we can implement the beginnings of, and not have to rip it all out later.</p>


	<h2  id="Architecture-overview">Architecture overview<a href="#Architecture-overview" class="wiki-anchor">&para;</a></h2>


	<p>I won't go back over all the details of the high level constructs, what was in the previous draft was discussion purposes.</p>


	<p>We have Templates.  A template describes an image.  Part of that description is a list of services provided (things supplied by an instance running this image, available to other instances).  Part is what the image requires (things that need to be available at runtime, provided either by other instances, the provider backend, or magic)</p>


	<p>We have Assemblies.  In the fullness of time, we expect assemblies to encompass the grouping of a base OS image, possibly other image-like things, possibly other things which live in the memory of the launched instance.  For the short term, an Assembly will reference only one image.  An assembly also may contain config info, ie more provides/requires entries.</p>


	<p>We have Deployables.  In the fullness of time, a deployable will describe the launch of N Assemblies, on N VM instances.  For the short term, we will implement only the degenerate case of a deployable launching a single assembly.  A deployable may also contain provides/requires entries.</p>


	<p>Service entries have parameters, which can be exported or imported.  A provided service has exported params, a required service has imports. Values for the params may be fixed (wired down by some stage of the template/assembly/deployable sequence) or computed (using a set of transformations which is TBD, and will likely start small and get larger) or specified by the user at launch time.  There may be other variants on how a particular value is bound.</p>


	<p>The cloud engine, at launch time, goes through the network of image descriptors, assemblies, and deployables, and binds all the required values.  This may involve staging the launches, or other techniques necessary to divine all the needed values.  A launch cannot proceed until the engine is able to resolve all the needed values.</p>


	<p>For each instance, once values are available for all its required parameters, a datastructure is produced describing them all.  This is nominally a list of key/value pairs; we might opt to wrap it up in some other structure, or something more complex, for instance if we end up supporting values which are themselves structured, like for instance lists of ip addresses or something.</p>


	<p>The per-instance datastructure of values is fed to a per-instance configuration tool, nominally puppet.  Puppet will have templates for the config files for the relevant apps and system pieces which are affected by the per-instance config.  Puppet takes the key/value pairs and uses them to fill in the templates, resulting in "personalized" conf files for all the relevant pieces in the booting instance.</p>


	<p>Ok, so with all that in mind, here are some approximately real-world examples.</p>


	<p>Ex 1.  I want to launch a cluster of 3 JBOSS servers, fronted by a load balancer.</p>


	<p>We need a deployable which describes 4 instances; 3 jboss servers, and one LB.</p>


<pre>
&lt;deployable&gt;
  &lt;assemblies&gt;
    &lt;assembly&gt;
      &lt;name&gt;LB&lt;/name&gt;
      &lt;type&gt;LBassy&lt;/type&gt;
      &lt;hardware-profile&gt;small&lt;/hardware-profile&gt;
    &lt;/assembly&gt;
    &lt;assembly&gt;
      &lt;name&gt;JB1&lt;/name&gt;
      &lt;type&gt;JBserverassy&lt;/type&gt;
      &lt;hardware-profile&gt;medium&lt;/hardware-profile&gt;
    &lt;/assembly&gt;
    &lt;assembly&gt;
      &lt;name&gt;JB2&lt;/name&gt;
      &lt;type&gt;JBserverassy&lt;/type&gt;
      &lt;hardware-profile&gt;medium&lt;/hardware-profile&gt;
    &lt;/assembly&gt;
    &lt;assembly&gt;
      &lt;name&gt;JB3&lt;/name&gt;
      &lt;type&gt;JBserverassy&lt;/type&gt;
      &lt;hardware-profile&gt;medium&lt;/hardware-profile&gt;
    &lt;/assembly&gt;
  &lt;/assemblies&gt;
&lt;deployable&gt;

&lt;assembly&gt;
  &lt;name&gt;LBassy&lt;/name&gt;
  &lt;image&gt;
    &lt;name&gt;LBtmpl&lt;/name&gt;
    &lt;services&gt;
      &lt;provides&gt;
        &lt;service&gt;
          &lt;name&gt;LBservice&lt;/name&gt;
          &lt;param&gt;
            &lt;name&gt;config-ip-address&lt;/name&gt;
            &lt;value&gt;
              &lt;compute-from-instance key=eth0-address&gt;
            &lt;/value&gt;
          &lt;/param&gt;
          &lt;param&gt;
            &lt;name&gt;config-port&lt;/name&gt;
            &lt;value&gt;&lt;fixed value=8080&gt;&lt;/value&gt;
          &lt;/param&gt;
        &lt;/service&gt;
      &lt;/provides&gt;
    &lt;/services&gt;
  &lt;/image&gt;
&lt;/assembly&gt;

</pre>

	<p>Several things to note about this assy: It provides a single service, called LBservice.  That service exports 2 parameters; config-ip-address and config-port.  Those make sense because this is the kind of LB where the clients come up and hit the address/port to register themselves, after which the LB starts handing them traffic. We'll make use of those values when configuring the client instances.</p>


<pre>
&lt;template&gt;
  &lt;name&gt;LBtmpl&lt;/name&gt;
  &lt;base-os&gt;RHEL5.5&lt;/base-os&gt;
  &lt;packages&gt;
    &lt;package&gt;my-lb-software&lt;/package&gt;
    ...
  &lt;/packages&gt;
  ...
&lt;/template&gt;
</pre><br />A couple things to note about this template:  It loads packages; the interesting one for the exposition is the LB software.  

	<p>Note further that for the load balancer, we've chosen to put none of the config in the template, instead putting all of it in the assembly. That may or may not make sense, depending on how the designer wants the pieces to fit together.  From the model point of view, it doesn't matter, as long as that config metadata is defined somewhere.</p>


<pre>
&lt;assembly&gt;
  &lt;name&gt;JBassy&lt;/name&gt;
  &lt;image&gt;
    &lt;name&gt;JBtmpl&lt;/name&gt;
  &lt;/image&gt;
&lt;/assembly&gt;

&lt;template&gt;
  &lt;name&gt;JBtmpl&lt;/name&gt;
  &lt;base-os&gt;RHEL5.5&lt;/base-os&gt;
  &lt;packages&gt;
    &lt;package&gt;jboss-server-app&lt;/package&gt;
    ...
    &lt;package&gt;my-puppet-plugin-for-lb-software&lt;/package&gt;
  &lt;/packages&gt;
  ...
  &lt;services&gt;
    &lt;requires&gt;
      &lt;service&gt;
        &lt;name&gt;LBservice&lt;/name&gt;
        &lt;param&gt;
          &lt;name&gt;config-ip-address&lt;/name&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;config-port&lt;/name&gt;
        &lt;/param&gt;
      &lt;/service&gt;
    &lt;/requires&gt;
  &lt;/services&gt;
&lt;/template&gt;
</pre>

	<p>Note that in this case, we've put the service config in the template, not the assembly.</p>


	<p>For this example, I've chosen to suppose that there's another package containing the puppet script/template needed by puppet at start time. That may or may not make sense; you can make the case that the puppet stuff really ought to be rolled in with the software to which it applies, in which case there would be only the one package.  You can also make the case that it should be kept separate, one the grounds that the jboss thing might want to control it a different way. You can also make the case that the fact of requiring service LBservice should automatically cause the my-puppet-plugin-for-lb-software package to be loaded.  We'll need to sort out which of those options we think makes sense.  That level of stuff is kind of up to the app designer, I think.</p>


	<p>Ok, we've got our interesting entities defined.  At launch time, the cloud engine will do the following:</p>


	<p>Look at the 4 instances being launched.</p>


	<p>Observe that we need to come up with values for config-ip-address and config-port, to be handed to each of 3 instances.</p>


	<p>Observe further that the 4th instance will supply those values when launched.  In fact, the port is defined as fixed value=8080, so we don't even need to launch to get that one.</p>


	<p>Decide, based on backend capabilities, what's needed to acquire the address.  In the simple case, it means launching the LB instance, enough to get its address.  That instance can be started.</p>


	<p>Once the address is available from launching the LB, it gets plugged into the matching param value slot in the config datastructure being built up for each of the JB instances.  Those instances can then be launched.</p>


	<p>In each JB instance, puppet wakes up and gets handed the address and port values.  Those are plugged into jboss-server.conf.  Then jboss is launched.  In due course, it reads the conf, and pings the LB on the designated address/port.</p>


	<p>Huzzah, now the app is running!</p>


	<p>Ex2:  Just like Ex1, but instead of launching the LB instance, we're running in a backend which has a hardware LB, like an F5 box or<br />something.</p>


	<p>This is somewhat similar, except that our deployable doesn't contain the LB software instance, and we don't have any of the related templates and assemblies.  Instead, what we have is a provider-config element, which is meant to be tagged onto the description of the provider.  In this scenario the CE does kind of what it did before, except that it knows at launch time what the LB's address is, because it's part of provider config.</p>


<pre>
&lt;deployable&gt;
  &lt;assemblies&gt;
    &lt;assembly&gt;
      &lt;name&gt;JB1&lt;/name&gt;
      &lt;type&gt;JBserverassy&lt;/type&gt;
      &lt;hardware-profile&gt;medium&lt;/hardware-profile&gt;
    &lt;/assembly&gt;
    &lt;assembly&gt;
      &lt;name&gt;JB2&lt;/name&gt;
      &lt;type&gt;JBserverassy&lt;/type&gt;
      &lt;hardware-profile&gt;medium&lt;/hardware-profile&gt;
    &lt;/assembly&gt;
    &lt;assembly&gt;
      &lt;name&gt;JB3&lt;/name&gt;
      &lt;type&gt;JBserverassy&lt;/type&gt;
      &lt;hardware-profile&gt;medium&lt;/hardware-profile&gt;
    &lt;/assembly&gt;
  &lt;/assemblies&gt;
&lt;deployable&gt;

&lt;assembly&gt;
  &lt;name&gt;JBassy&lt;/name&gt;
  &lt;image&gt;
    &lt;name&gt;JBtmpl&lt;/name&gt;
  &lt;/image&gt;
&lt;/assembly&gt;

&lt;template&gt;
  &lt;name&gt;JBtmpl&lt;/name&gt;
  &lt;base-os&gt;RHEL5.5&lt;/base-os&gt;
  &lt;packages&gt;
    &lt;package&gt;jboss-server-app&lt;/package&gt;
    ...
    &lt;package&gt;my-puppet-plugin-for-lb-software&lt;/package&gt;
  &lt;/packages&gt;
  ...
  &lt;services&gt;
    &lt;requires&gt;
      &lt;service&gt;
        &lt;name&gt;LBservice&lt;/name&gt;
        &lt;param&gt;
          &lt;name&gt;config-ip-address&lt;/name&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;config-port&lt;/name&gt;
        &lt;/param&gt;
      &lt;/service&gt;
    &lt;/provides&gt;
  &lt;/services&gt;
&lt;/template&gt;

&lt;providerconfig&gt;
  &lt;services&gt;
    &lt;provides&gt;
      &lt;service&gt;
        &lt;name&gt;LBservice&lt;/name&gt;
        &lt;param&gt;
          &lt;name&gt;ip-address&lt;/name&gt;
          &lt;value&gt;&lt;fixed value=192.23.24.25/&gt;&lt;/value&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;port&lt;/name&gt;
          &lt;value&gt;&lt;fixed value=9090/&gt;&lt;/value&gt;
        &lt;/param&gt;
      &lt;/service&gt;
    &lt;/provides&gt;
  &lt;/services&gt;
&lt;/providerconfig&gt;
</pre>

	<p>In some ways this is simpler than the first one, because there's less dependency stuff going on at launch time.  All the CE has to do is resolve to the provided service from the provider, and plug the values that way.  They're both fixed, so no further computation is required.</p>


	<p>The other thing to note is that the template and assembly for the JBserver are identical to the first example.  You could literally use the same images and templates, in a different deployable, to deploy this different configuration.</p>


	<p>Let's try a third variant.</p>


	<p>Ex3:  Same as Ex1, but we're using a different kind of load balancer. This load balancer doesn't have the ability to have clients auto-register, instead it's told at launch time what the IP addresses of its clients are.</p>


<pre>
&lt;deployable&gt;
  &lt;assemblies&gt;
    &lt;assembly&gt;
      &lt;name&gt;LB&lt;/name&gt;
      &lt;type&gt;LBassy&lt;/type&gt;
      &lt;hardware-profile&gt;small&lt;/hardware-profile&gt;
    &lt;/assembly&gt;
    &lt;assembly&gt;
      &lt;name&gt;JB1&lt;/name&gt;
      &lt;type&gt;JBserverassy&lt;/type&gt;
      &lt;hardware-profile&gt;medium&lt;/hardware-profile&gt;
    &lt;/assembly&gt;
    &lt;assembly&gt;
      &lt;name&gt;JB2&lt;/name&gt;
      &lt;type&gt;JBserverassy&lt;/type&gt;
      &lt;hardware-profile&gt;medium&lt;/hardware-profile&gt;
    &lt;/assembly&gt;
    &lt;assembly&gt;
      &lt;name&gt;JB3&lt;/name&gt;
      &lt;type&gt;JBserverassy&lt;/type&gt;
      &lt;hardware-profile&gt;medium&lt;/hardware-profile&gt;
    &lt;/assembly&gt;
  &lt;/assemblies&gt;
&lt;deployable&gt;

&lt;assembly&gt;
  &lt;name&gt;LBassy&lt;/name&gt;
  &lt;image&gt;
    &lt;name&gt;LBtmpl&lt;/name&gt;
    &lt;services&gt;
      &lt;requires&gt;
        &lt;service&gt;
          &lt;name&gt;LBclient&lt;/name&gt;
          &lt;vector&gt;
            &lt;param&gt;
              &lt;name&gt;ip-address&lt;/name&gt;
            &lt;/param&gt;
            &lt;param&gt;
              &lt;name&gt;port&lt;/name&gt;
            &lt;/param&gt;
          &lt;/vector&gt;
        &lt;/service&gt;
      &lt;/requires&gt;
    &lt;/services&gt;
  &lt;/image&gt;
&lt;/assembly&gt;
</pre>

	<p>The main thing that's different here is that we've moved the required config to the LB.  Furthermore, because we expect to be able to pass in a bunch of key/val pairs for the clients, we introduce the notion of a vector of key/vals.  The semantics (I hypothesize) would be that the CE would group up all the ip addresses and ports from all the clients in the deployable which export the LBclient service, and present that as config to the LB instance.</p>


<pre>
&lt;template&gt;
  &lt;name&gt;LBtmpl&lt;/name&gt;
  &lt;base-os&gt;RHEL5.5&lt;/base-os&gt;
  &lt;packages&gt;
    &lt;package&gt;my-lb-software&lt;/package&gt;
    ...
    &lt;package&gt;my-puppet-plugin-for-lb-software&lt;/package&gt;
  &lt;/packages&gt;
  ...
&lt;/template&gt;
</pre>

	<p>In this case, we've also put the package which carries the config templates and puppet stuff in the LB image.  Similar caveat to in Ex1, you can make the case that it should be part of the my-lb-software package.  Or not.</p>


	<p>Note also that in this model, my-puppet-plugin-for-lb-software doesn't do what it did in the other; this one walks the vector of incoming values, and populates lb.conf with them.</p>


<pre>
&lt;assembly&gt;
  &lt;name&gt;JBassy&lt;/name&gt;
  &lt;image&gt;
    &lt;name&gt;JBtmpl&lt;/name&gt;
  &lt;/image&gt;
  &lt;services&gt;
    &lt;provides&gt;
      &lt;service&gt;
        &lt;name&gt;LBservice&lt;/name&gt;
        &lt;param&gt;
          &lt;name&gt;ip-address&lt;/name&gt;
          &lt;value&gt;
            &lt;compute-from-instance key=eth0-address&gt;
          &lt;/value&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;port&lt;/name&gt;
          &lt;value&gt;&lt;fixed value=80/&gt;&lt;/value&gt;
        &lt;/param&gt;
      &lt;/service&gt;
    &lt;/provides&gt;
  &lt;/services&gt;
&lt;/assembly&gt;

&lt;template&gt;
  &lt;name&gt;JBtmpl&lt;/name&gt;
  &lt;base-os&gt;RHEL5.5&lt;/base-os&gt;
  &lt;packages&gt;
    &lt;package&gt;jboss-server-app&lt;/package&gt;
    ...
  &lt;/packages&gt;
  ...
&lt;/template&gt;
</pre>

	<p>Here, we've removed the requires, and added a provides in the JB assembly.  This one is similar to the above, in that it says to pick the address assigned to the instance's eth0 at boot time, and fixes the port at 80.</p>


	<p>For this scenario, the CE would again do dependency checking, except that it would come to a different conclusion.  The 3 JB instances would be launched, enough to get their IP addresses, then the addresses and ports collected up and handed to the LB, which can then be launched.</p>


	<p>Ex4: I have an app (App1) which wants to nfs-mount read-only something from a public server.  It also wants to nfs-mount read-write something from some other server, as private data.  I have two jboss server things, similar to above, and a load balancer which talks to them. All of App1 and the two JBs want access to a private network, which is provided by the backend infrastructure.  Those three instances want to talk to each other over that private network.</p>


	<p>We'll stipulate that the LB is software, and configured via registration, as in Ex1.</p>


<pre>
&lt;template&gt;
  &lt;name&gt;LBtmpl&lt;/name&gt;
  &lt;base-os&gt;RHEL5.5&lt;/base-os&gt;
  &lt;packages&gt;
    &lt;package&gt;my-lb-software&lt;/package&gt;
    ...
  &lt;/packages&gt;
  ...
&lt;/template&gt;

&lt;assembly&gt;
  &lt;name&gt;LBassy&lt;/name&gt;
  &lt;image&gt;
    &lt;name&gt;LBtmpl&lt;/name&gt;
    &lt;services&gt;
      &lt;provides&gt;
        &lt;service&gt;
          &lt;name&gt;LBservice&lt;/name&gt;
          &lt;param&gt;
            &lt;name&gt;config-ip-address&lt;/name&gt;
            &lt;value&gt;
              &lt;compute-from-instance key=eth0-address&gt;
            &lt;/value&gt;
          &lt;/param&gt;
          &lt;param&gt;
            &lt;name&gt;config-port&lt;/name&gt;
            &lt;value&gt;&lt;fixed value=8080&gt;&lt;/value&gt;
          &lt;/param&gt;
        &lt;/service&gt;
      &lt;/provides&gt;
    &lt;/services&gt;
  &lt;/image&gt;
&lt;/assembly&gt;

</pre>

	<p>The JB template looks like the one in Ex1 as well.  The assembly around it includes config for the VLAN.  Yes, we could have put that in the template if we thought that made sense.  Likewise we could have put the LB config in the assembly.  There will need to be some best-practices dox written about all this stuff.</p>


<pre>
&lt;template&gt;
  &lt;name&gt;JBtmpl&lt;/name&gt;
  &lt;base-os&gt;RHEL5.5&lt;/base-os&gt;
  &lt;packages&gt;
    &lt;package&gt;jboss-server-app&lt;/package&gt;
    ...
    &lt;package&gt;my-puppet-plugin-for-lb-software&lt;/package&gt;
  &lt;/packages&gt;
  ...
  &lt;services&gt;
    &lt;requires&gt;
      &lt;service&gt;
        &lt;name&gt;LBservice&lt;/name&gt;
        &lt;param&gt;
          &lt;name&gt;config-ip-address&lt;/name&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;config-port&lt;/name&gt;
        &lt;/param&gt;
      &lt;/service&gt;
    &lt;/requires&gt;
  &lt;/services&gt;
&lt;/template&gt;

&lt;assembly&gt;
  &lt;name&gt;JBassy&lt;/name&gt;
  &lt;image&gt;
    &lt;name&gt;JBtmpl&lt;/name&gt;
  &lt;/image&gt;
  &lt;services&gt;
    &lt;requires&gt;
      &lt;service&gt;
        &lt;name&gt;VLAN&lt;/name&gt;
        &lt;param&gt;
          &lt;name&gt;ip-address&lt;/name&gt;
        &lt;/param&gt;
        &lt;vector&gt;
          &lt;param&gt;
            &lt;name&gt;neighbor-instance-type&lt;/name&gt;
          &lt;/param&gt;
          &lt;param&gt;
            &lt;name&gt;ip-address&lt;/name&gt;
          &lt;/param&gt;
        &lt;/vector&gt;
      &lt;/service&gt;
    &lt;/requires&gt;
  &lt;/services&gt;
&lt;/assembly&gt;

</pre>

	<p>The template and assembly for App1.  This one is a bit more complicated, because it needs to describe two NFS mounts.  For each of them, it needs five values: the server, base URI (the thing which is exportfs'ed, probably, though maybe not), the sub-URI, the mount point, and the mode.  Perhaps we should not separate base URI and sub-URI?</p>


	<p>It also references the VLAN, the same way the JBs do.</p>


<pre>
&lt;template&gt;
  &lt;name&gt;App1&lt;/name&gt;
  &lt;base-os&gt;RHEL5.5&lt;/base-os&gt;
  &lt;packages&gt;
    &lt;package&gt;app1-libs&lt;/package&gt;
    &lt;package&gt;app1-core&lt;/package&gt;
    ...
    &lt;package&gt;my-puppet-plugin-for-app1&lt;/package&gt;
  &lt;/packages&gt;
  ...
  &lt;services&gt;
    &lt;requires&gt;
      &lt;service&gt;
        &lt;name&gt;GlobalNFSApps&lt;/name&gt;
        &lt;param&gt;
          &lt;name&gt;ip-address&lt;/name&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;base-uri&lt;/name&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;app-uri&lt;/name&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;mount-point&lt;/name&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;mount-mode&lt;/name&gt;
          &lt;value&gt;&lt;fixed name=ro/&gt;&lt;/value&gt;
        &lt;/param&gt;
      &lt;/service&gt;
      &lt;service&gt;
        &lt;name&gt;PrivateNFSApps&lt;/name&gt;
        &lt;param&gt;
          &lt;name&gt;ip-address&lt;/name&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;base-uri&lt;/name&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;app-uri&lt;/name&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;mount-point&lt;/name&gt;
          &lt;value&gt;&lt;fixed value="/mnt/local"/&gt;&lt;/value&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;mount-mode&lt;/name&gt;
          &lt;value&gt;&lt;fixed value=rw/&gt;&lt;/value&gt;
        &lt;/param&gt;
      &lt;/service&gt;
      &lt;service&gt;
        &lt;name&gt;VLAN&lt;/name&gt;
        &lt;param&gt;
          &lt;name&gt;ip-address&lt;/name&gt;
        &lt;/param&gt;
        &lt;vector&gt;
          &lt;param&gt;
            &lt;name&gt;neighbor-instance-type&lt;/name&gt;
          &lt;/param&gt;
          &lt;param&gt;
            &lt;name&gt;ip-address&lt;/name&gt;
          &lt;/param&gt;
        &lt;/vector&gt;
      &lt;/service&gt;
    &lt;/requires&gt;
  &lt;/services&gt;
&lt;/template&gt;

&lt;assembly&gt;
  &lt;name&gt;App1assy&lt;/name&gt;
  &lt;image&gt;
    &lt;name&gt;App1tmpl&lt;/name&gt;
  &lt;/image&gt;
&lt;/assembly&gt;

</pre>

	<p>We need a provider-config to describe the server(s) which will be used to satisfy the nfs services.</p>


<pre>
&lt;providerconfig&gt;
  &lt;services&gt;
    &lt;provides&gt;
      &lt;service&gt;
        &lt;name&gt;GlobalNFSApps&lt;/name&gt;
        &lt;type&gt;nfs-server&lt;/type&gt;
        &lt;param&gt;
          &lt;name&gt;ip-address&lt;/name&gt;
          &lt;value&gt;&lt;fixed value="10.100.0.1"/&gt;&lt;/value&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;base-uri&lt;/name&gt;
          &lt;value&gt;&lt;fixed value="/var/storage/app"/&gt;&lt;/value&gt;
        &lt;/param&gt;
      &lt;/service&gt;
      &lt;service&gt;
        &lt;name&gt;PrivateNFSApps&lt;/name&gt;
        &lt;type&gt;nfs-server&lt;/type&gt;
        &lt;param&gt;
          &lt;name&gt;ip-address&lt;/name&gt;
          &lt;value&gt;&lt;fixed value="10.100.0.2"/&gt;&lt;/value&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;base-uri&lt;/name&gt;
          &lt;value&gt;&lt;fixed value="/var/misc"/&gt;&lt;/value&gt;
        &lt;/param&gt;
      &lt;/service&gt;
      &lt;service&gt;
        &lt;name&gt;Our Cloud VLAN&lt;/name&gt;
        &lt;type&gt;VLAN&lt;/type&gt;
      &lt;/service&gt;
    &lt;/provides&gt;
  &lt;/services&gt;
&lt;/providerconfig&gt;
</pre>

	<p>And finally, the deployable which ties all these bits together.</p>


<pre>
&lt;deployable&gt;
  &lt;assemblies&gt;
    &lt;assembly&gt;
      &lt;name&gt;LB&lt;/name&gt;
      &lt;type&gt;LBassy&lt;/type&gt;
      &lt;hardware-profile&gt;small&lt;/hardware-profile&gt;
    &lt;/assembly&gt;
    &lt;assembly&gt;
      &lt;name&gt;App1&lt;/name&gt;
      &lt;type&gt;App1assy&lt;/type&gt;
      &lt;hardware-profile&gt;large&lt;/hardware-profile&gt;
      &lt;service&gt;
        &lt;name&gt;VLAN&lt;/name&gt;
        &lt;param&gt;
          &lt;name&gt;ip-address&lt;/name&gt;
          &lt;value&gt;&lt;fixed value="10.1.2.3"/&gt;&lt;/value&gt;
        &lt;/param&gt;
      &lt;/service&gt;
      &lt;service&gt;
        &lt;name&gt;GlobalNFSApps&lt;/name&gt;
        &lt;param&gt;
          &lt;name&gt;app-uri&lt;/name&gt;
          &lt;value&gt;&lt;fixed value="/app1-static-data"/&gt;&lt;/value&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;mount-point&lt;/name&gt;
          &lt;value&gt;&lt;fixed value="/mnt/foo"/&gt;&lt;/value&gt;
        &lt;/param&gt;
      &lt;/service&gt;
      &lt;service&gt;
        &lt;name&gt;PrivateNFSApps&lt;/name&gt;
        &lt;param&gt;
          &lt;name&gt;app-uri&lt;/name&gt;
          &lt;value&gt;&lt;fixed value="/app1-dynamic-data"/&gt;&lt;/value&gt;
        &lt;/param&gt;
        &lt;param&gt;
          &lt;name&gt;mount-point&lt;/name&gt;
          &lt;value&gt;&lt;fixed value="/mnt/bar"/&gt;&lt;/value&gt;
        &lt;/param&gt;
      &lt;/service&gt;
    &lt;/assembly&gt;
    &lt;assembly&gt;
      &lt;name&gt;JB1&lt;/name&gt;
      &lt;type&gt;JBserverassy&lt;/type&gt;
      &lt;hardware-profile&gt;medium&lt;/hardware-profile&gt;
      &lt;service&gt;
        &lt;name&gt;VLAN&lt;/name&gt;
        &lt;param&gt;
          &lt;name&gt;ip-address&lt;/name&gt;
          &lt;value&gt;&lt;fixed value="10.1.2.4"/&gt;&lt;/value&gt;
        &lt;/param&gt;
      &lt;/service&gt;
    &lt;/assembly&gt;
    &lt;assembly&gt;
      &lt;name&gt;JB2&lt;/name&gt;
      &lt;type&gt;JBserverassy&lt;/type&gt;
      &lt;hardware-profile&gt;medium&lt;/hardware-profile&gt;
      &lt;service&gt;
        &lt;name&gt;VLAN&lt;/name&gt;
        &lt;param&gt;
          &lt;name&gt;ip-address&lt;/name&gt;
          &lt;value&gt;&lt;fixed value="10.1.2.5"/&gt;&lt;/value&gt;
        &lt;/param&gt;
      &lt;/service&gt;
    &lt;/assembly&gt;
  &lt;/assemblies&gt;
&lt;deployable&gt;
</pre>

	<p>A few interesting things about this one.</p>


	<p>For the NFS servers, we've intentionally sprinkled the config around, to illustrate the point that in real life, you want to nail down some things here, nail down some more things at a different level of abstraction, and finally resolve the last bits at launch time.  For instance if we were going to launch multiple instances of App1, we'd probably want to change their app-uri values to be computed from instance name or something similar.  But we would leave the mount point the same.</p>


	<p>The astute reader will observe that we've almost created a circular dependency for ourselves, with the VLAN config.  In the case above, we're fixing all the IP addresses on the VLAN in the config, but that often won't be feasible in the real world.  In many cases you'll have a situation where you want to launch a bunch of things, and want to tell all of them about their peers, but you don't what what information to propagate until they're launched.</p>


	<p>For these kinds of cases, there will need to be some variety of checkin after launch.  If all the instances check in with the mother ship, we're able to wait for all the checkins, then propagate the aggregate data back out to all the relevant consumers.  There are already tools out there which do this kind of thing, for instance matahari.  When we get to the point of launching these distributed apps, we can investigate integrating something like matahari in here, or possibly just build that functionality into the cloud engine proper.</p>


	<p>There are some other issues which will need to be sorted out over time.  The astute reader will also notice that in previous drafts we've put some parameters in a section called config.  In this one it's all moved into services.  I <strong>believe</strong> it can be made to work either way, but we might decide it makes more sense to treat config as a standalone construct.  Or not.</p>


	<p>Another construction which I believe we will need, but have not explored enough yet, is the notion of a provided service which requires a parameter.  This will likely hair up the param syntax a bit, by explicitly specifying required/provided on each param, rather than doing it by implication as part of a required/provided service.</p>


	<p>It would be good to have at least a little discussion of these points before we declare what we're building for rev1.</p>


	<p>The point of all this is meant to be that we believe the model works. We claim that we can implement the simple parts of this (templates, singleton assemblies and deployables, single-instance config stuff) and have a decent level of confidence that it will extend to the more complex cases when we get there.</p>


	<p>Finally, let's talk about the backend a bit.  Ohad Levy has been kind enough to whip up some sample puppet scriptage which should illustrate how we could do the last mile (well, last few inches) of the config on a booting instance.</p>


	<p>Here's an example of an sshd_config which is parameterized to allow for setting the port from outside.</p>


<pre>
Port &lt;%= has_variable?("ssh_port") ? ssh_port : "22" %&gt;
&lt;%# ssh_port rescue "22" -%&gt;
#AddressFamily any
#ListenAddress 0.0.0.0
#ListenAddress ::

# The default requires explicit activation of protocol 1
#Protocol 2

# HostKey for protocol version 1
#HostKey /etc/ssh/ssh_host_key
# HostKeys for protocol version 2
#HostKey /etc/ssh/ssh_host_rsa_key
#HostKey /etc/ssh/ssh_host_dsa_key

# Lifetime and size of ephemeral version 1 server key
#KeyRegenerationInterval 1h
#ServerKeyBits 1024

# Logging
# obsoletes QuietMode and FascistLogging
#SyslogFacility AUTH
SyslogFacility AUTHPRIV
#LogLevel INFO

# Authentication:

#LoginGraceTime 2m
#PermitRootLogin yes
#StrictModes yes
#MaxAuthTries 6
#MaxSessions 10

#RSAAuthentication yes
#PubkeyAuthentication yes
#AuthorizedKeysFile     .ssh/authorized_keys
#PubkeyAgent none
#PubkeyAgentRunAs nobody

# For this to work you will also need host keys in /etc/ssh/ssh_known_hosts
#RhostsRSAAuthentication no
# similar for protocol version 2
#HostbasedAuthentication no
# Change to yes if you don't trust ~/.ssh/known_hosts for
# RhostsRSAAuthentication and HostbasedAuthentication
#IgnoreUserKnownHosts no
# Don't read the user's ~/.rhosts and ~/.shosts files
#IgnoreRhosts yes

# To disable tunneled clear text passwords, change to no here!
#PasswordAuthentication yes
#PermitEmptyPasswords no
PasswordAuthentication yes

# Change to no to disable s/key passwords
#ChallengeResponseAuthentication yes
ChallengeResponseAuthentication no

# Kerberos options
#KerberosAuthentication no
#KerberosOrLocalPasswd yes
#KerberosTicketCleanup yes
#KerberosGetAFSToken no

# GSSAPI options
#GSSAPIAuthentication no
GSSAPIAuthentication yes
#GSSAPICleanupCredentials yes
GSSAPICleanupCredentials yes
#GSSAPIStrictAcceptorCheck yes
#GSSAPIKeyExchange no

# Set this to 'yes' to enable PAM authentication, account processing, 
# and session processing. If this is enabled, PAM authentication will 
# be allowed through the ChallengeResponseAuthentication and
# PasswordAuthentication.  Depending on your PAM configuration,
# PAM authentication via ChallengeResponseAuthentication may bypass
# the setting of "PermitRootLogin without-password".
# If you just want the PAM account and session checks to run without
# PAM authentication, then enable this but set PasswordAuthentication
# and ChallengeResponseAuthentication to 'no'.
#UsePAM no
UsePAM yes

# Accept locale-related environment variables
AcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES
AcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT
AcceptEnv LC_IDENTIFICATION LC_ALL LANGUAGE
AcceptEnv XMODIFIERS

#AllowAgentForwarding yes
#AllowTcpForwarding yes
#GatewayPorts no
#X11Forwarding no
X11Forwarding yes
#X11DisplayOffset 10
#X11UseLocalhost yes
#PrintMotd yes
#PrintLastLog yes
#TCPKeepAlive yes
#UseLogin no
#UsePrivilegeSeparation yes
#PermitUserEnvironment no
#Compression delayed
#ClientAliveInterval 0
#ClientAliveCountMax 3
#ShowPatchLevel no
#UseDNS yes
#PidFile /var/run/sshd.pid
#MaxStartups 10
#PermitTunnel no
#ChrootDirectory none

# no default banner path
#Banner none

# override default of no subsystems
Subsystem       sftp    /usr/libexec/openssh/sftp-server

# Example of overriding settings on a per-user basis
#Match User anoncvs
#       X11Forwarding no
#       AllowTcpForwarding no
#       ForceCommand cvs server
</pre>

	<p>This is a pretty simple contrived example, but it should illustrate the basic mechanism we propose to use.</p>
</body>
</html>
